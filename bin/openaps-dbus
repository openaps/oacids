#!/usr/bin/python
# PYTHON_ARGCOMPLETE_OK

# import gobject
from gi.repository import GObject as gobject
import dbus.service
import time
import sys
import argparse, argcomplete
from dbus.gi_service import ExportedGObject

from dbus import validate_interface_name
import _dbus_bindings
import inspect

# http://cyberelk.net/tim/2011/08/16/d-bus-and-python-asynchronous-method-implementation/
# https://coelhorjc.wordpress.com/2014/12/09/howto-write-dbus-service-for-linux-in-python/
# http://stackoverflow.com/questions/34851085/how-to-stop-a-dbus-gobject-loop/34860020#34860020

BUS='com.example.Timer'
IFACE='com.example.Timer'

ObjectManager = 'org.freedesktop.DBus.ObjectManager'
PATH='/com/example/Timer'
START_TIME=time.time ()

INTROSPECTABLE_IFACE='org.freedesktop.DBus.Introspectable'


# class WithProperties (dbus.service.Object):
class WithProperties (ExportedGObject):
  
    def _reflect_on_property(cls, func):
        args = func._dbus_args

        if func._dbus_type_signature:
            # convert signature into a tuple so length refers to number of
            # types, not number of characters. the length is checked by
            # the decorator to make sure it matches the length of args.
            type_sig = tuple(Signature(func._dbus_type_signature))
        else:
            # magic iterator which returns as many v's as we need
            type_sig = _VariantSignature()

        access = None
        if func._dbus_access:
            access = func._dbus_access
            out_sig = Signature(func._dbus_out_signature)
        else:
            # its tempting to default to Signature('v'), but
            # for methods that return nothing, providing incorrect
            # introspection data is worse than providing none at all
            out_sig = []

        reflection_data = '    <property name="%s" type="%s" access="%s">\n' % (func.__name__, type_sig, access)
        for annotation in getattr(func, '_dbus_annotations', [ ]):
            reflection_data += '      <annotation name="%s" value="true" />\n' % pair
            # reflection_data += '      <arg direction="in"  type="%s" name="%s" />\n' % pair

        reflection_data += '    </property>\n'

        return reflection_data
    def _reflect_on_gproperty(cls, prop):
        gname = prop.name.replace('-', '_')
        print "gname", gname
        type_sig = cls.PROP_SIGS.get(gname, 'v')
        access_map = {
          gobject.PARAM_READWRITE: 'readwrite'
        , gobject.PARAM_READABLE: 'read'
        , gobject.PARAM_WRITABLE: 'write'
        }
        access = 'read'
        if getattr(cls.__class__, gname, None):
          access = access_map.get(getattr(cls.__class__, gname).flags, 'read')
        reflection_data = '    <property name="%s" type="%s" access="%s">\n' % (gname, type_sig, access)
        for annotation in getattr(prop, '_dbus_annotations', [ ]):
            reflection_data += '      <annotation name="%s" value="true" />\n' % pair
            # reflection_data += '      <arg direction="in"  type="%s" name="%s" />\n' % pair

        reflection_data += '    </property>\n'

        return reflection_data
    @dbus.service.method(INTROSPECTABLE_IFACE, in_signature='', out_signature='s',
            path_keyword='object_path', connection_keyword='connection')
    def Introspect(self, object_path, connection):
        """Return a string of XML encoding this object's supported interfaces,
        methods and signals.
        """
        reflection_data = _dbus_bindings.DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE
        reflection_data += '<node name="%s">\n' % object_path

        interfaces = self._dbus_class_table[self.__class__.__module__ + '.' + self.__class__.__name__]
        for (name, funcs) in interfaces.items():
            reflection_data += '  <interface name="%s">\n' % (name)

            if name == self.OWN_IFACE:
              for prop in self.props:
                reflection_data += self._reflect_on_gproperty(prop)

            for func in funcs.values():
                if getattr(func, '_dbus_is_method', False):
                    reflection_data += self.__class__._reflect_on_method(func)
                elif getattr(func, '_dbus_is_signal', False):
                    reflection_data += self.__class__._reflect_on_signal(func)
                elif getattr(func, '_dbus_is_property', False):
                    reflection_data += self.__class__._reflect_on_property(func)


            reflection_data += '  </interface>\n'

        for name in connection.list_exported_child_objects(object_path):
            reflection_data += '  <node name="%s"/>\n' % name

        reflection_data += '</node>\n'

        return reflection_data

class GPropSync (WithProperties):
    PROP_SIGS = { }
    def __init__ (self, bus=None, path=PATH):
        self.bus = bus or dbus.SessionBus( )
        ExportedGObject.__init__(self, self.bus.get_connection( ), path)
        self.sync_all_props( )
    def sync_all_props (self):
      for prop in self.props:
        self.connect("notify::%s" % prop.name, self.on_prop_change)
    def on_prop_change (self, obj, gparam):
      changed = {gparam.name.replace('-', '_'): getattr(self, gparam.name.replace('-', '_'))}
      # print changed
      self.PropertiesChanged(self.OWN_IFACE, changed, {})

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE, in_signature='ss', out_signature='v')
    def Get(self, interface_name, property_name):
        return self.GetAll(interface_name)[property_name]

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='s', out_signature='a{sv}')
    def GetAll(self, interface_name):
        if interface_name == self.OWN_IFACE:
            props = dict([(prop.name.replace('-', '_'), getattr(self, prop.name.replace('-', '_'))) for prop in self.props])
            return props
        else:
            raise dbus.exceptions.DBusException(
                'com.example.UnknownInterface',
                'The Foo object does not implement the %s interface'
                    % interface_name)

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='ssv')
    def Set(self, interface_name, property_name, new_value):
        # validate the property name and value, update internal state
        if interface_name == self.OWN_IFACE:
          self.set_property(property_name, new_value)
        # self.PropertiesChanged(interface_name,
            # { property_name: new_value }, [])

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
                         signature='sa{sv}as')
    def PropertiesChanged(self, interface_name, changed_properties,
                          invalidated_properties):
        print "dbus signal PropertiesChanged"
        pass

# class Timer(dbus.service.Object):
# class Timer(ExportedGObject):
class Manager (WithProperties):
    OWN_IFACE = IFACE
    # ObjectManager
    schedules = [ ]
    def __init__ (self, path, bus=None):
      # self.__dbus_object_path__ = path
      self.bus = bus or dbus.SessionBus( )
      WithProperties.__init__(self, self.bus.get_connection( ), path)

    @dbus.service.method(dbus_interface=ObjectManager,
                         in_signature='', out_signature='a{oa{sa{sv}}}')
    def GetManagedObjects(self):
      return self.get_all_managed( )
      return [ ]
    @dbus.service.signal(dbus_interface=ObjectManager,
                         signature='oa{sa{sv}}')
    def InterfacesAdded (self, path, iface_spec):
      pass
    @dbus.service.signal(dbus_interface=ObjectManager,
                         signature='oas')
    def InterfacesRemoved (self, path, iface_spec):
      pass

TRIGGER_IFACE = IFACE + '.Trigger'
class Trigger (GPropSync):
  OWN_IFACE = TRIGGER_IFACE
  PROP_SIGS = {
    'name': 's'
  }
  name = gobject.property(type=str)
  def __init__ (self, path, bus=None, props=None):
    self.bus = bus or dbus.SessionBus( )
    WithProperties.__init__(self, self.bus.get_connection( ), path)
    if props:
      for key in props:
        self.set_property(key, props[key])
    self.sync_all_props( )
  @dbus.service.method(dbus_interface=TRIGGER_IFACE,
                       in_signature='', out_signature='',
                       async_callbacks=('ack', 'error'))
  def Remove (self, ack=None, error=None):
    ack( )
class ScheduleManager (Manager):
  def __init__ (self, bus, path):
    self.bus = bus
    self.path = path
    Manager.__init__(self, path, bus)
  def init_managed (self):
    self.schedules = [ ]
  def get_all_managed (self):
    managed = self.schedules
    return managed
  @dbus.service.method(dbus_interface=IFACE,
                       in_signature='a{sv}', out_signature='')
                       # , async_callbacks=('ack', 'error'))
  # def Create (self, props, ack=None, error=None):
  def Create (self, props):
    path = "%s/Trigger%s" % (self.path, len(self.schedules))
    new_schedule = Trigger(path, self.bus, props)
    print "NEW SCHEDULE", new_schedule
    self.schedules.append(new_schedule)
    self.InterfacesAdded(path, { TRIGGER_IFACE: props })



def is_running (bus, NAME):
    request = bus.request_name(NAME, dbus.bus.NAME_FLAG_DO_NOT_QUEUE)
    if request != dbus.bus.REQUEST_NAME_REPLY_EXISTS:
      return False
    return True

class Timer (ScheduleManager, WithProperties):
    OWN_IFACE = IFACE
    PROP_SIGS = {
      'fuel': 'i'
    , 'blah': 's'
    , 'name': 's'
    , 'mode': 's'
    , 'status': 'u'
    , 'ini_home': 's'
    }
    blah = gobject.property(type=str)
    ini_home = gobject.property(type=str, default=".")
    mode = gobject.property(type=str, flags=gobject.PARAM_READABLE, default='foo')

    @gobject.property(type=int, flags=gobject.PARAM_READABLE, default=0)
    def status (self):

      return 0

    # describe_property(dbus_interface=IFACE, type_signature='s') ()
    name = gobject.property(type=str)
    def __init__ (self, loop, bus=None, path=PATH):
        self.loop = loop
        self.bus = bus or dbus.SessionBus( )
        self.path = path
        request = self.bus.request_name(BUS, dbus.bus.NAME_FLAG_DO_NOT_QUEUE)
        self.running = False
        if request != dbus.bus.REQUEST_NAME_REPLY_EXISTS:
          bus_name = dbus.service.BusName (BUS, bus=self.bus)
          print "bus_name", bus_name
          ExportedGObject.__init__(self, self.bus.get_connection( ), PATH, bus_name=bus_name, name= 'foo'  )
          print "props", self.props
          for x in self.props:
            print "x", x, x.name
          for prop in self.props:
            self.connect("notify::%s" % prop.name, self.on_prop_change)

          # self.schedules = Manager(path + '/Manager1', bus)



          # dbus.service.Object.__init__ (self, bus_name, PATH)
          self.name = 'foobar'
        else:
          self.running = True
          print "running already"
          # raise Exception("Already exists")

    @dbus.service.method(dbus_interface=IFACE,
                         in_signature='i',
                         out_signature='i',
                         async_callbacks=('reply_handler',
                                          'error_handler'))
    def Delay (self, seconds, reply_handler, error_handler):
        print "Sleeping for %ds" % seconds
        gobject.timeout_add_seconds (seconds,
                                     lambda: reply_handler (seconds))

    @dbus.service.method(dbus_interface=IFACE,
                         in_signature='', out_signature='')
    def Howdy(self):
      print "Howdy!"

    @dbus.service.method(dbus_interface=IFACE,
                         in_signature='', out_signature='s')
    def Start (self):
      print "Howdy!"
      return "OK"

    @dbus.service.method(dbus_interface=IFACE,
                         in_signature='', out_signature='')
    def Exit(self):
      print "Exiting!"
      self.Quit( )
      return
      # self.loop.quit()

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
                         signature='')
    def Quit (self):
      gobject.timeout_add(2, self.loop.quit)
      # self.loop.quit()
      
    @classmethod
    def App (Klass, args=None):
      from dbus.mainloop.glib import DBusGMainLoop
      DBusGMainLoop (set_as_default=True)
      loop = gobject.MainLoop ()
      dbus.mainloop.glib.threads_init( )
      # Start the heartbeat
      handle = gobject.timeout_add_seconds (1, heartbeat)
      print "STarting", sys.argv
      bus = dbus.SessionBus( )
      op = make_args_op(args)
      if args.quit or is_running(bus, BUS):
        print "Already running"
        proxy = bus.get_object(BUS, PATH)
        app = dbus.Interface (proxy, IFACE)
        print app
        app.operate(op)
        # app.Howdy( )
        return app
      else:
        timer = Timer (loop, bus)
        timer.running = True
        timer.operate(op)
        loop.run ()
        timer.running = False
        return timer
        

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE, in_signature='ss', out_signature='v')
    def Get(self, interface_name, property_name):
        return self.GetAll(interface_name)[property_name]

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='s', out_signature='a{sv}')
    def GetAll(self, interface_name):
        if interface_name == IFACE:
            props = dict([(prop.name.replace('-', '_'), getattr(self, prop.name.replace('-', '_'))) for prop in self.props])
            return props
        else:
            raise dbus.exceptions.DBusException(
                'com.example.UnknownInterface',
                'The Foo object does not implement the %s interface'
                    % interface_name)

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='ssv')
    def Set(self, interface_name, property_name, new_value):
        # validate the property name and value, update internal state
        if interface_name == self.OWN_IFACE:
          self.set_property(property_name, new_value)
        # self.PropertiesChanged(interface_name,
            # { property_name: new_value }, [])

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
                         signature='sa{sv}as')
    def PropertiesChanged(self, interface_name, changed_properties,
                          invalidated_properties):
        print "dbus signal PropertiesChanged"
        pass
    def on_prop_change (self, obj, gparam):
      print "dEBUG"
      print gparam
      changed = {gparam.name.replace('-', '_'): getattr(self, gparam.name.replace('-', '_'))}
      print changed
      self.PropertiesChanged(IFACE, changed, {})

    @dbus.service.method(dbus_interface=IFACE, in_signature='a{sv}', out_signature='v')
    def operate(self, kwds):
      print "OPERATE", kwds
      if 'ini_home' in kwds:
        self.ini_home = kwds['ini_home']
      if 'name' in kwds:
        self.name = kwds['name']
      if 'create' in kwds:
        self.Create(kwds['create'])
      return 0

def heartbeat():
    print "Still alive at", time.time () - START_TIME
    return True

def main (args):
  pass

def make_args_op (args):
  op = dict( )
  if args.ini_home:
    op.update(ini_home=args.ini_home)
  if args.name:
    print "setting name", args.name
    op.update(name=args.name)
  if args.create:
    op.update(create=dict(name=args.create))
  return op

if __name__ == '__main__':
  parser = argparse.ArgumentParser( )
  parser.add_argument('--quit', action='store_true', default=False)
  parser.add_argument('--name')
  parser.add_argument('--ini_home')
  parser.add_argument('--create')
  argcomplete.autocomplete(parser)
  args = parser.parse_args( )
  main(args)
  app = Timer.App(args)

  if args.quit:
    app.Exit( )
    # app.name = args.name
  # app.dispatch(args)
  """
  from dbus.mainloop.glib import DBusGMainLoop
  DBusGMainLoop (set_as_default=True)
  loop = gobject.MainLoop ()
  dbus.mainloop.glib.threads_init( )
  # Start the heartbeat
  handle = gobject.timeout_add_seconds (1, heartbeat)
  print "STarting", sys.argv
  timer = Timer (loop)
  request = timer.bus.request_name(BUS, dbus.bus.NAME_FLAG_DO_NOT_QUEUE)
  if request != dbus.bus.REQUEST_NAME_REPLY_EXISTS:
    # Start the D-Bus service
    app = timer
    loop.run ()
    print loop
  else:
    print "Already running", 'running howdy'
    proxy = timer.bus.get_object(BUS, PATH)
    app = dbus.Interface (proxy, IFACE)
    print app
    app.Howdy( )
  """

